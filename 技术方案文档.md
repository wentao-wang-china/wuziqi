# 赛博朋克风格五子棋游戏 - 技术方案文档

```
CC：需求：做一个网页版的小游戏 五子棋。游戏中要有高中低三种难度。画风要是赛博朋克风格。先来做一个整体计划。

计划生成后，并未直接生成技术方案文档，而是询问是否进入开发。此时要跟cc说明，不进入开发阶段，先调试技术方案文档。
```

## 1. 项目概述

### 1.1 项目简介
本项目旨在开发一款网页版赛博朋克风格五子棋游戏，支持人机对战，提供低、中、高三种AI难度选择，具备悔棋功能和沉浸式音效动画。

### 1.2 技术选型
- **前端技术**: 纯 HTML5 + CSS3 + ES6+ JavaScript
- **绘图技术**: Canvas API
- **AI算法**: Minimax + Alpha-Beta 剪枝
- **音频**: Web Audio API / HTML5 Audio
- **无依赖**: 不使用任何第三方框架和库

### 1.3 核心特性
- ✅ 标准15x15五子棋规则
- ✅ 三档AI难度（低/中/高）
- ✅ 赛博朋克视觉风格（霓虹发光效果）
- ✅ 悔棋功能（撤销玩家+AI各一步）
- ✅ 音效系统（落子、胜利、点击）
- ✅ 动画效果（落子动画、胜利高亮）
- ✅ 响应式设计

---

## 2. 系统架构设计

### 2.1 整体架构
```
┌─────────────────────────────────────────────┐
│              用户界面层 (UI Layer)             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │  Canvas  │  │  控制面板 │  │  模态框   │   │
│  │  棋盘区   │  │  按钮区   │  │  难度选择 │   │
│  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────┘
                     ↕
┌─────────────────────────────────────────────┐
│            业务逻辑层 (Logic Layer)           │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │   游戏    │  │    AI    │  │   UI     │   │
│  │  控制器   │  │   引擎   │  │  控制器   │   │
│  │ (Game)   │  │  (AI)    │  │  (UI)    │   │
│  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────┘
                     ↕
┌─────────────────────────────────────────────┐
│            数据层 (Data Layer)               │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │   棋盘    │  │   历史   │  │   音效   │   │
│  │  状态     │  │   记录   │  │  管理器  │   │
│  │ (Board)  │  │(History) │  │ (Audio)  │   │
│  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────┘
```

### 2.2 模块划分

#### 核心模块
| 模块名称 | 文件 | 职责 |
|---------|------|------|
| 棋盘系统 | `board.js` | 棋盘状态管理、渲染、历史记录 |
| 游戏引擎 | `game.js` | 游戏流程控制、规则判定 |
| AI引擎 | `ai.js` | Minimax算法、难度控制 |
| UI控制器 | `ui.js` | 用户交互、界面更新 |
| 音效管理 | `audio.js` | 音效加载、播放控制 |
| 工具函数 | `utils.js` | 通用辅助函数 |

### 2.3 目录结构
```
wuziqi/
├── index.html                    # 主页面
├── 技术方案文档.md                # 本文档
├── css/
│   ├── main.css                  # 主样式（布局、组件）
│   └── cyberpunk.css             # 赛博朋克主题样式
├── js/
│   ├── game.js                   # 游戏主控制器
│   ├── board.js                  # 棋盘逻辑
│   ├── ai.js                     # AI算法引擎
│   ├── ui.js                     # UI交互控制
│   ├── audio.js                  # 音效管理器
│   └── utils.js                  # 工具函数库
└── assets/
    ├── sounds/                   # 音效文件目录
    │   ├── place.mp3             # 落子音效
    │   ├── win.mp3               # 胜利音效
    │   └── click.mp3             # 按钮点击音效
    └── fonts/                    # 字体文件（可选）
        └── Orbitron-*.woff2      # 赛博朋克字体
```

---

## 3. 核心模块详细设计

### 3.1 棋盘系统 (board.js)

#### 3.1.1 数据结构
```javascript
class Board {
  constructor(size = 15) {
    this.size = size;                    // 棋盘大小 15x15
    this.grid = [];                      // 二维数组 [row][col]
    this.history = [];                   // 历史记录 [{row, col, player}]
    this.lastMove = null;                // 最后一手 {row, col}
    this.canvas = null;                  // Canvas元素
    this.ctx = null;                     // Canvas上下文
    this.cellSize = 40;                  // 格子大小（像素）
    this.padding = 30;                   // 边距
  }
}
```

#### 3.1.2 核心方法
```javascript
// 初始化棋盘
initGrid()                               // 创建空棋盘二维数组

// 渲染相关
render()                                 // 绘制完整棋盘
drawGrid()                               // 绘制网格线（带发光效果）
drawStones()                             // 绘制所有棋子
drawStone(row, col, player)              // 绘制单个棋子（带渐变发光）
drawLastMoveMarker()                     // 标记最后一手

// 交互相关
getCellFromPosition(x, y)                // 鼠标坐标转棋盘坐标
isValidMove(row, col)                    // 判断落子是否合法
makeMove(row, col, player)               // 执行落子
undoMove()                               // 悔棋（移除最后一手）

// 坐标转换
getCellCenter(row, col)                  // 棋盘坐标转Canvas像素坐标
```

#### 3.1.3 Canvas绘制技术要点

**网格线发光效果**:
```javascript
drawGrid() {
  const ctx = this.ctx;
  ctx.strokeStyle = '#00f3ff';
  ctx.lineWidth = 1;
  ctx.shadowBlur = 10;
  ctx.shadowColor = '#00f3ff';

  // 绘制横线和竖线
  for (let i = 0; i < this.size; i++) {
    // 横线
    ctx.beginPath();
    ctx.moveTo(x1, y);
    ctx.lineTo(x2, y);
    ctx.stroke();
    // 竖线...
  }
}
```

**棋子渐变发光**:
```javascript
drawStone(row, col, player) {
  const {x, y} = this.getCellCenter(row, col);
  const radius = this.cellSize * 0.4;

  // 创建径向渐变
  const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
  if (player === 'black') {
    gradient.addColorStop(0, '#8000ff');   // 中心紫色
    gradient.addColorStop(1, '#1a0033');   // 边缘深紫
  } else {
    gradient.addColorStop(0, '#00f3ff');   // 中心青色
    gradient.addColorStop(1, '#003344');   // 边缘深青
  }

  // 绘制发光效果
  ctx.shadowBlur = 20;
  ctx.shadowColor = player === 'black' ? '#8000ff' : '#00f3ff';
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
}
```

---

### 3.2 游戏引擎 (game.js)

#### 3.2.1 数据结构
```javascript
class Game {
  constructor() {
    this.board = new Board(15);          // 棋盘实例
    this.currentPlayer = 'black';        // 当前玩家 (black/white)
    this.gameState = 'playing';          // 游戏状态 (playing/blackWin/whiteWin/draw)
    this.playerSide = 'black';           // 玩家执黑/白
    this.aiSide = 'white';               // AI执黑/白
    this.difficulty = 'medium';          // AI难度 (easy/medium/hard)
    this.ai = null;                      // AI实例
    this.isAiThinking = false;           // AI思考标志
  }
}
```

#### 3.2.2 核心方法
```javascript
// 游戏流程
start(difficulty)                        // 开始游戏
restart()                                // 重新开始
handlePlayerMove(row, col)               // 处理玩家落子
handleAiMove()                           // 处理AI落子
switchPlayer()                           // 切换回合

// 规则判定
checkWin(row, col, player)               // 检查是否五连胜利
checkDirection(row, col, dr, dc, player) // 检查单个方向连子数
checkDraw()                              // 检查是否平局（棋盘满）

// 悔棋
undo()                                   // 悔棋（撤销玩家和AI各一步）
```

#### 3.2.3 五连判定算法
```javascript
checkWin(row, col, player) {
  // 四个方向：横、竖、左斜、右斜
  const directions = [
    [0, 1],   // 水平
    [1, 0],   // 垂直
    [1, 1],   // 右下斜
    [1, -1]   // 左下斜
  ];

  for (let [dr, dc] of directions) {
    let count = 1; // 当前位置算1个

    // 正方向检查
    count += this.countDirection(row, col, dr, dc, player);
    // 反方向检查
    count += this.countDirection(row, col, -dr, -dc, player);

    if (count >= 5) {
      // 记录五连线的起止位置用于高亮
      this.winLine = this.getWinLine(row, col, dr, dc, player);
      return true;
    }
  }
  return false;
}

countDirection(row, col, dr, dc, player) {
  let count = 0;
  let r = row + dr;
  let c = col + dc;

  while (r >= 0 && r < 15 && c >= 0 && c < 15 &&
         this.board.grid[r][c] === player) {
    count++;
    r += dr;
    c += dc;
  }
  return count;
}
```

---

### 3.3 AI引擎 (ai.js)

#### 3.3.1 数据结构
```javascript
class AI {
  constructor(difficulty = 'medium') {
    this.difficulty = difficulty;
    this.maxDepth = this.getDepthByDifficulty(difficulty);
    this.player = 'white';               // AI执子颜色
    this.opponent = 'black';             // 对手颜色
    this.searchCount = 0;                // 搜索节点计数（调试用）
  }

  getDepthByDifficulty(difficulty) {
    switch(difficulty) {
      case 'easy': return 1;             // 低难度：1层
      case 'medium': return 2;           // 中难度：2层
      case 'hard': return 3;             // 高难度：3层
      default: return 2;
    }
  }
}
```

#### 3.3.2 Minimax算法核心
```javascript
/**
 * Minimax算法 + Alpha-Beta剪枝
 * @param {Board} board - 棋盘状态
 * @param {number} depth - 当前搜索深度
 * @param {number} alpha - Alpha值（最大化）
 * @param {number} beta - Beta值（最小化）
 * @param {boolean} isMaximizing - 是否最大化（AI回合）
 * @returns {number} 评估分数
 */
minimax(board, depth, alpha, beta, isMaximizing) {
  this.searchCount++;

  // 终止条件1: 深度为0
  if (depth === 0) {
    return this.evaluate(board);
  }

  // 终止条件2: 游戏结束
  const winner = this.checkGameOver(board);
  if (winner === this.player) return 100000;      // AI胜
  if (winner === this.opponent) return -100000;   // 玩家胜

  // 获取候选落子点
  const candidates = this.getCandidateMoves(board);
  if (candidates.length === 0) return 0;          // 平局

  if (isMaximizing) {
    // AI回合，最大化分数
    let maxEval = -Infinity;

    for (let move of candidates) {
      // 尝试落子
      board.makeMove(move.row, move.col, this.player);

      // 递归搜索
      let eval = this.minimax(board, depth - 1, alpha, beta, false);

      // 撤销落子
      board.undoMove();

      maxEval = Math.max(maxEval, eval);
      alpha = Math.max(alpha, eval);

      // Beta剪枝
      if (beta <= alpha) break;
    }
    return maxEval;

  } else {
    // 玩家回合，最小化分数
    let minEval = Infinity;

    for (let move of candidates) {
      board.makeMove(move.row, move.col, this.opponent);
      let eval = this.minimax(board, depth - 1, alpha, beta, true);
      board.undoMove();

      minEval = Math.min(minEval, eval);
      beta = Math.min(beta, eval);

      // Alpha剪枝
      if (beta <= alpha) break;
    }
    return minEval;
  }
}
```

#### 3.3.3 最佳落子点选择
```javascript
/**
 * 获取AI的最佳落子点
 * @param {Board} board - 当前棋盘
 * @returns {{row: number, col: number}} 最佳位置
 */
getBestMove(board) {
  this.searchCount = 0;

  // 第一步：落在中心
  if (board.history.length === 0) {
    return {row: 7, col: 7};
  }

  // 检查必杀点（己方四连或对方四连）
  const criticalMove = this.findCriticalMove(board);
  if (criticalMove) return criticalMove;

  // 获取候选点
  const candidates = this.getCandidateMoves(board);

  let bestMove = null;
  let bestScore = -Infinity;
  let alpha = -Infinity;
  let beta = Infinity;

  for (let move of candidates) {
    board.makeMove(move.row, move.col, this.player);

    // 从对手角度评估（Min层）
    const score = this.minimax(board, this.maxDepth - 1, alpha, beta, false);

    board.undoMove();

    if (score > bestScore) {
      bestScore = score;
      bestMove = move;
    }
    alpha = Math.max(alpha, score);
  }

  console.log(`AI搜索节点数: ${this.searchCount}`);
  return bestMove;
}
```

#### 3.3.4 评估函数
```javascript
/**
 * 评估棋盘局面分数
 * @param {Board} board - 棋盘状态
 * @returns {number} 评估分数（正数有利于AI，负数有利于玩家）
 */
evaluate(board) {
  let score = 0;

  // 评估AI方
  score += this.evaluatePlayer(board, this.player);

  // 评估对手方（乘以权重，防守略低于进攻）
  score -= this.evaluatePlayer(board, this.opponent) * 0.9;

  return score;
}

/**
 * 评估某一方的分数
 */
evaluatePlayer(board, player) {
  let score = 0;
  const size = board.size;

  // 四个方向：横、竖、两个斜
  const directions = [[0,1], [1,0], [1,1], [1,-1]];

  for (let row = 0; row < size; row++) {
    for (let col = 0; col < size; col++) {
      if (board.grid[row][col] !== player) continue;

      for (let [dr, dc] of directions) {
        const pattern = this.getPattern(board, row, col, dr, dc, player);
        score += this.getPatternScore(pattern);
      }
    }
  }

  return score;
}

/**
 * 获取连子模式评分
 */
getPatternScore(pattern) {
  const {count, openEnds, hasSpace} = pattern;

  // 五连及以上
  if (count >= 5) return 100000;

  // 活四（两端开放）
  if (count === 4 && openEnds === 2) return 10000;

  // 冲四（一端开放）
  if (count === 4 && openEnds === 1) return 1000;

  // 活三
  if (count === 3 && openEnds === 2) return 1000;

  // 眠三
  if (count === 3 && openEnds === 1) return 100;

  // 活二
  if (count === 2 && openEnds === 2) return 100;

  // 眠二
  if (count === 2 && openEnds === 1) return 10;

  // 单子
  if (count === 1) return 1;

  return 0;
}
```

#### 3.3.5 候选点生成优化
```javascript
/**
 * 获取候选落子点（性能优化关键）
 * 只搜索已有棋子周围2格范围内的空位
 */
getCandidateMoves(board) {
  const candidates = new Set();
  const range = 2; // 搜索半径

  // 如果棋盘为空，返回中心点
  if (board.history.length === 0) {
    return [{row: 7, col: 7}];
  }

  // 遍历所有已落子位置
  for (let {row, col} of board.history) {
    // 搜索周围range格内的空位
    for (let dr = -range; dr <= range; dr++) {
      for (let dc = -range; dc <= range; dc++) {
        const r = row + dr;
        const c = col + dc;

        if (r >= 0 && r < board.size &&
            c >= 0 && c < board.size &&
            board.grid[r][c] === null) {
          candidates.add(`${r},${c}`);
        }
      }
    }
  }

  // 转换为坐标数组并按评估分数排序（启发式搜索）
  return Array.from(candidates).map(key => {
    const [row, col] = key.split(',').map(Number);
    return {row, col};
  }).sort((a, b) => {
    // 简单启发：优先搜索中心区域
    const distA = Math.abs(a.row - 7) + Math.abs(a.col - 7);
    const distB = Math.abs(b.row - 7) + Math.abs(b.col - 7);
    return distA - distB;
  }).slice(0, 20); // 限制候选点数量（性能优化）
}

/**
 * 查找必杀点（优先级最高）
 * - AI己方四连：必须立即完成五连
 * - 对手四连：必须立即防守
 */
findCriticalMove(board) {
  // 先检查己方四连（进攻优先）
  let move = this.findWinningMove(board, this.player);
  if (move) return move;

  // 再检查对手四连（防守）
  move = this.findWinningMove(board, this.opponent);
  if (move) return move;

  return null;
}

findWinningMove(board, player) {
  const candidates = this.getCandidateMoves(board);

  for (let move of candidates) {
    board.makeMove(move.row, move.col, player);
    const isWin = this.checkWin(board, move.row, move.col, player);
    board.undoMove();

    if (isWin) return move;
  }

  return null;
}
```

---

### 3.4 UI控制器 (ui.js)

#### 3.4.1 数据结构
```javascript
class UI {
  constructor(game) {
    this.game = game;
    this.elements = {
      canvas: null,
      statusText: null,
      restartBtn: null,
      undoBtn: null,
      soundToggle: null,
      difficultyModal: null,
      difficultyBtns: []
    };
    this.hoverCell = null; // 鼠标悬停位置
  }
}
```

#### 3.4.2 核心方法
```javascript
// 初始化
init()                                   // 初始化UI，绑定事件
bindEvents()                             // 绑定所有事件监听器

// 事件处理
handleCanvasClick(e)                     // Canvas点击事件
handleCanvasMouseMove(e)                 // Canvas鼠标移动（悬停预览）
handleRestart()                          // 重新开始按钮
handleUndo()                             // 悔棋按钮
handleSoundToggle()                      // 音效开关
handleDifficultySelect(difficulty)       // 难度选择

// 界面更新
updateStatus(message)                    // 更新状态文本
showWinner(winner)                       // 显示胜利信息
enableControls()                         // 启用控制按钮
disableControls()                        // 禁用控制按钮（AI思考时）
showDifficultyModal()                    // 显示难度选择对话框
hideDifficultyModal()                    // 隐藏难度选择对话框

// 悬停预览
drawHoverPreview(row, col)               // 绘制半透明预览棋子
clearHoverPreview()                      // 清除预览
```

---

### 3.5 音效管理器 (audio.js)

#### 3.5.1 数据结构
```javascript
class AudioManager {
  constructor() {
    this.sounds = {
      place: null,    // 落子音效
      win: null,      // 胜利音效
      click: null     // 点击音效
    };
    this.enabled = true; // 音效开关
    this.volume = 0.5;   // 音量
  }
}
```

#### 3.5.2 核心方法
```javascript
// 初始化
async loadSounds()                       // 加载所有音效文件
loadSound(name, url)                     // 加载单个音效

// 播放控制
play(soundName)                          // 播放指定音效
stop(soundName)                          // 停止音效
toggle()                                 // 切换音效开关
setVolume(volume)                        // 设置音量
```

#### 3.5.3 音效实现
```javascript
async loadSounds() {
  try {
    this.sounds.place = await this.loadSound('place', 'assets/sounds/place.mp3');
    this.sounds.win = await this.loadSound('win', 'assets/sounds/win.mp3');
    this.sounds.click = await this.loadSound('click', 'assets/sounds/click.mp3');
  } catch (error) {
    console.warn('音效加载失败:', error);
  }
}

loadSound(name, url) {
  return new Promise((resolve, reject) => {
    const audio = new Audio(url);
    audio.volume = this.volume;
    audio.addEventListener('canplaythrough', () => resolve(audio), {once: true});
    audio.addEventListener('error', reject, {once: true});
    audio.load();
  });
}

play(soundName) {
  if (!this.enabled || !this.sounds[soundName]) return;

  const sound = this.sounds[soundName];
  sound.currentTime = 0; // 重置播放位置
  sound.play().catch(err => console.warn('播放失败:', err));
}
```

---

## 4. 视觉设计方案

### 4.1 赛博朋克配色系统

#### 4.1.1 CSS变量定义
```css
:root {
  /* 主题色 - 霓虹色 */
  --neon-blue: #00f3ff;
  --neon-pink: #ff006e;
  --neon-purple: #8000ff;
  --neon-green: #39ff14;

  /* 背景色 */
  --bg-dark: #0a0e27;
  --bg-darker: #050714;
  --bg-panel: #1a1a2e;

  /* 文字色 */
  --text-primary: #00f3ff;
  --text-secondary: #8899aa;
  --text-glow: 0 0 10px var(--neon-blue);

  /* 网格线 */
  --grid-color: #00f3ff;
  --grid-glow: 0 0 10px var(--neon-blue);

  /* 棋子颜色 */
  --stone-black: #8000ff;
  --stone-white: #00f3ff;
}
```

#### 4.1.2 发光效果样式类
```css
/* 文字发光 */
.text-glow {
  color: var(--neon-blue);
  text-shadow:
    0 0 5px var(--neon-blue),
    0 0 10px var(--neon-blue),
    0 0 20px var(--neon-blue);
}

/* 边框发光 */
.border-glow {
  border: 2px solid var(--neon-blue);
  box-shadow:
    0 0 5px var(--neon-blue),
    0 0 10px var(--neon-blue),
    inset 0 0 5px var(--neon-blue);
}

/* 按钮发光悬停 */
.btn-cyber {
  background: transparent;
  border: 2px solid var(--neon-blue);
  color: var(--neon-blue);
  padding: 10px 20px;
  font-family: 'Orbitron', monospace;
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
  overflow: hidden;
}

.btn-cyber:hover {
  background: var(--neon-blue);
  color: var(--bg-dark);
  box-shadow:
    0 0 20px var(--neon-blue),
    inset 0 0 10px rgba(0, 243, 255, 0.3);
  transform: translateY(-2px);
}

.btn-cyber::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  transition: left 0.5s;
}

.btn-cyber:hover::before {
  left: 100%;
}
```

### 4.2 布局设计

#### 4.2.1 整体布局
```css
body {
  background: linear-gradient(135deg, var(--bg-darker) 0%, var(--bg-dark) 100%);
  font-family: 'Orbitron', 'Courier New', monospace;
  color: var(--text-primary);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
}

/* 背景网格动画 */
body::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image:
    linear-gradient(var(--neon-blue) 1px, transparent 1px),
    linear-gradient(90deg, var(--neon-blue) 1px, transparent 1px);
  background-size: 50px 50px;
  opacity: 0.05;
  animation: gridScroll 20s linear infinite;
}

@keyframes gridScroll {
  0% { transform: translate(0, 0); }
  100% { transform: translate(50px, 50px); }
}
```

#### 4.2.2 游戏容器
```css
.game-container {
  display: flex;
  gap: 30px;
  z-index: 1;
  animation: fadeIn 1s ease-in;
}

.board-section {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.control-panel {
  background: var(--bg-panel);
  padding: 30px;
  border-radius: 10px;
  border: 2px solid var(--neon-blue);
  box-shadow:
    0 0 20px rgba(0, 243, 255, 0.3),
    inset 0 0 20px rgba(0, 243, 255, 0.1);
}
```

### 4.3 Canvas样式
```css
#gameCanvas {
  border: 3px solid var(--neon-blue);
  border-radius: 5px;
  box-shadow:
    0 0 30px rgba(0, 243, 255, 0.5),
    inset 0 0 20px rgba(0, 243, 255, 0.1);
  background: radial-gradient(circle at center, #0f1428 0%, #0a0e27 100%);
  cursor: crosshair;
}
```

---

## 5. 动画系统设计

### 5.1 落子动画
```javascript
/**
 * 落子动画：缩放 + 淡入 + 发光脉冲
 */
class StoneAnimation {
  constructor(board, row, col, player) {
    this.board = board;
    this.row = row;
    this.col = col;
    this.player = player;
    this.progress = 0;      // 动画进度 0-1
    this.duration = 300;    // 持续时间（毫秒）
    this.startTime = Date.now();
  }

  update() {
    const elapsed = Date.now() - this.startTime;
    this.progress = Math.min(elapsed / this.duration, 1);
    return this.progress < 1; // 返回是否继续动画
  }

  draw(ctx) {
    const {x, y} = this.board.getCellCenter(this.row, this.col);
    const radius = this.board.cellSize * 0.4;

    // 缓动函数：easeOutBack（超出后回弹）
    const t = this.progress;
    const scale = t < 0.5
      ? 2 * t * t
      : -1 + (4 - 2 * t) * t;

    const currentRadius = radius * scale;
    const alpha = this.progress;

    // 绘制带透明度和缩放的棋子
    ctx.globalAlpha = alpha;
    ctx.shadowBlur = 20 + (1 - this.progress) * 30; // 脉冲发光

    // 渐变和绘制...

    ctx.globalAlpha = 1;
  }
}
```

### 5.2 胜利动画
```javascript
/**
 * 胜利动画：五连线高亮闪烁
 */
class WinAnimation {
  constructor(winLine) {
    this.winLine = winLine; // [{row, col}, ...]
    this.progress = 0;
    this.duration = 2000;
    this.startTime = Date.now();
  }

  update() {
    const elapsed = Date.now() - this.startTime;
    this.progress = (elapsed % this.duration) / this.duration;
    return true; // 持续循环
  }

  draw(ctx, board) {
    // 正弦波闪烁效果
    const alpha = 0.5 + Math.sin(this.progress * Math.PI * 2) * 0.5;

    ctx.strokeStyle = '#ff006e';
    ctx.lineWidth = 5;
    ctx.globalAlpha = alpha;
    ctx.shadowBlur = 30;
    ctx.shadowColor = '#ff006e';

    // 绘制连线
    const start = board.getCellCenter(this.winLine[0].row, this.winLine[0].col);
    const end = board.getCellCenter(
      this.winLine[this.winLine.length-1].row,
      this.winLine[this.winLine.length-1].col
    );

    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(end.x, end.y);
    ctx.stroke();

    ctx.globalAlpha = 1;
  }
}
```

### 5.3 动画管理器
```javascript
class AnimationManager {
  constructor(board) {
    this.board = board;
    this.animations = [];
    this.isRunning = false;
  }

  add(animation) {
    this.animations.push(animation);
    if (!this.isRunning) {
      this.start();
    }
  }

  start() {
    this.isRunning = true;
    this.loop();
  }

  loop() {
    if (this.animations.length === 0) {
      this.isRunning = false;
      return;
    }

    // 更新所有动画
    this.animations = this.animations.filter(anim => anim.update());

    // 重绘棋盘
    this.board.render();

    // 绘制动画层
    this.animations.forEach(anim => anim.draw(this.board.ctx));

    requestAnimationFrame(() => this.loop());
  }
}
```

---

## 6. 性能优化方案

### 6.1 AI算法优化

#### 6.1.1 候选点剪枝
- 只搜索已落子周围2格范围
- 限制候选点数量上限（20个）
- 按启发式分数排序优先搜索

#### 6.1.2 Alpha-Beta剪枝
- 减少50-90%的搜索节点
- 最佳移动排序（Move Ordering）

#### 6.1.3 Zobrist哈希（可选高级优化）
```javascript
class TranspositionTable {
  constructor() {
    this.table = new Map();
    this.maxSize = 100000;
  }

  get(hash, depth) {
    const entry = this.table.get(hash);
    if (entry && entry.depth >= depth) {
      return entry.score;
    }
    return null;
  }

  set(hash, depth, score) {
    if (this.table.size >= this.maxSize) {
      // 删除最旧的条目
      const firstKey = this.table.keys().next().value;
      this.table.delete(firstKey);
    }
    this.table.set(hash, {depth, score});
  }
}
```

### 6.2 Canvas渲染优化

#### 6.2.1 分层渲染
```javascript
// 静态层：网格线（不常变化）
this.staticCanvas = document.createElement('canvas');
this.staticCtx = this.staticCanvas.getContext('2d');
this.drawGrid(); // 只绘制一次

// 动态层：棋子（频繁变化）
this.render() {
  // 先绘制静态层
  this.ctx.drawImage(this.staticCanvas, 0, 0);
  // 再绘制棋子
  this.drawStones();
}
```

#### 6.2.2 局部重绘
```javascript
// 只重绘变化区域
redrawCell(row, col) {
  const {x, y} = this.getCellCenter(row, col);
  const size = this.cellSize;

  this.ctx.clearRect(x - size, y - size, size * 2, size * 2);
  // 重绘该区域...
}
```

### 6.3 Web Worker（可选）
```javascript
// ai-worker.js
self.onmessage = function(e) {
  const {board, difficulty} = e.data;
  const ai = new AI(difficulty);
  const bestMove = ai.getBestMove(board);
  self.postMessage(bestMove);
};

// 主线程调用
const worker = new Worker('ai-worker.js');
worker.postMessage({board: boardState, difficulty: 'hard'});
worker.onmessage = (e) => {
  const move = e.data;
  // 执行AI落子...
};
```

---

## 7. 开发流程与测试

### 7.1 开发步骤

#### Phase 1: 基础框架（第1-2天）
- [ ] 创建HTML结构
- [ ] 实现赛博朋克CSS样式
- [ ] 搭建基本页面布局

#### Phase 2: 棋盘系统（第3天）
- [ ] 实现Board类
- [ ] Canvas网格绘制（发光效果）
- [ ] 棋子绘制（渐变发光）
- [ ] 坐标转换和点击检测

#### Phase 3: 游戏逻辑（第4天）
- [ ] 实现Game类
- [ ] 五连判定算法
- [ ] 回合管理
- [ ] 基础UI集成

#### Phase 4: AI算法（第5-6天）
- [ ] Minimax算法核心
- [ ] Alpha-Beta剪枝
- [ ] 评估函数
- [ ] 候选点生成
- [ ] 难度调试

#### Phase 5: 功能完善（第7天）
- [ ] 悔棋功能
- [ ] UI交互完善
- [ ] 音效系统
- [ ] 动画效果

#### Phase 6: 测试优化（第8天）
- [ ] 功能测试
- [ ] 性能优化
- [ ] 浏览器兼容性测试

### 7.2 测试计划

#### 7.2.1 功能测试
- [ ] 五连判定（横竖斜四个方向）
- [ ] AI三种难度合理性
- [ ] 悔棋功能正确性
- [ ] 音效播放
- [ ] 动画流畅性

#### 7.2.2 边界测试
- [ ] 棋盘边角位置
- [ ] 平局情况（棋盘满）
- [ ] 连续悔棋
- [ ] 快速点击

#### 7.2.3 性能测试
- [ ] AI响应时间（高难度<3秒）
- [ ] Canvas渲染FPS（>30fps）
- [ ] 内存占用

#### 7.2.4 兼容性测试
- [ ] Chrome/Edge
- [ ] Firefox
- [ ] Safari
- [ ] 移动端浏览器

---

## 8. 技术难点与解决方案

### 8.1 难点1: AI性能与难度平衡

**问题**: 高难度搜索深度过大导致响应慢

**解决方案**:
1. 限制候选点数量（周围2格+上限20个）
2. Alpha-Beta剪枝减少搜索节点
3. 必杀点优先检测
4. 可选Web Worker异步计算

### 8.2 难点2: Canvas发光效果性能

**问题**: shadowBlur导致渲染性能下降

**解决方案**:
1. 分层渲染（静态层+动态层）
2. 缓存发光图案
3. 减少不必要的重绘

### 8.3 难点3: 评估函数准确性

**问题**: 简单评估函数导致AI智能不足

**解决方案**:
1. 分析连子模式（活三、冲四等）
2. 区分进攻和防守权重
3. 增加位置价值评估（中心优先）

### 8.4 难点4: 移动端适配

**问题**: Canvas在移动端分辨率和触摸事件

**解决方案**:
1. 使用devicePixelRatio适配高清屏
2. 同时监听touch和mouse事件
3. 响应式布局调整Canvas大小

---

## 9. 扩展功能建议

### 9.1 短期扩展（V1.1）
- [ ] 本地排行榜（localStorage记录胜率）
- [ ] 游戏回放功能
- [ ] 多种棋盘主题切换
- [ ] 音效音量调节

### 9.2 中期扩展（V1.2）
- [ ] 双人对战模式
- [ ] 禁手规则选项（五子棋竞技规则）
- [ ] AI提示功能（显示推荐落子点）
- [ ] 游戏保存/加载

### 9.3 长期扩展（V2.0）
- [ ] 在线对战（WebSocket）
- [ ] 深度学习AI（TensorFlow.js）
- [ ] 全局排行榜（后端API）
- [ ] 社交分享功能

---

## 10. 总结

本技术方案设计了一个功能完整、视觉炫酷的赛博朋克风格五子棋游戏，核心技术点包括：

1. **AI算法**: Minimax + Alpha-Beta剪枝，通过搜索深度和评估函数实现三档难度
2. **视觉效果**: 赛博朋克霓虹发光风格，Canvas渲染高品质棋盘和棋子
3. **用户体验**: 流畅的交互、悔棋功能、音效动画增强沉浸感
4. **性能优化**: 候选点剪枝、分层渲染、局部重绘保证流畅运行

项目采用纯原生技术栈，无框架依赖，代码结构清晰，易于维护和扩展。

---

**文档版本**: v1.0
**最后更新**: 2026-01-20
**作者**: Claude Code
